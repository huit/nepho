#!/usr/bin/env python

# Dummy driver for a simple CLI, which uses aws-cli
#
#   https://github.com/aws/aws-cli
#
# This simple code is mostly taken from awscli.clidriver
#
# 

import sys
import logging

import botocore.session
from botocore.hooks import first_non_none_response
from botocore.hooks import HierarchicalEmitter
from botocore import xform_name
from botocore.compat import copy_kwargs, OrderedDict

from awscli import clidriver

import awscli.clidriver
from awscli import EnvironmentVariables, __version__
from awscli.formatter import get_formatter
from awscli.paramfile import get_paramfile
from awscli.plugin import load_plugins
from awscli.argparser import MainArgParser
from awscli.argparser import ServiceArgParser
from awscli.argparser import OperationArgParser
#from awscli.help import ProviderHelpCommand
#from awscli.help import ServiceHelpCommand
#from awscli.help import OperationHelpCommand
from awscli.argprocess import unpack_cli_arg
import argparse

from jinja2 import Environment, FileSystemLoader

import json
import collections
import yaml
import string
from hu.command import command

LOG = logging.getLogger('hu-dummy')

def setup_awscli_driver():
    emitter = HierarchicalEmitter()
    session = botocore.session.Session(EnvironmentVariables, emitter)
    session.user_agent_name = 'aws-cli'
    session.user_agent_version = __version__
    load_plugins(session.full_config.get('plugins', {}), event_hooks=emitter)
    return awscli.clidriver.CLIDriver(session=session)
            
def main():
    # Create an aws-cli driver
    aws_driver = setup_awscli_driver()

    # Read in command line options as JSON    
    args_json = command()
    args=json.loads(args_json)

    # Very basic parsing to determine deployment and environment to use
    plugin_name = args['subcmd']
    deployment_name = args['deployment']
    env_name = args['opts']['environment']
    
    # Load settings from YAML deployment file
    paramsMap = dict()
    pattern = None
    yaml_file = './deployments/%s.yaml' % (deployment_name)
    try:
        f = open(yaml_file)
        yamlMap = yaml.safe_load(f)
        f.close()
        envMap = yamlMap[env_name]
        for k in envMap.keys():
            paramsMap[k] = envMap[k]
    except IOError as e: 
        print "Error parsing deployment file \"%s\"" % (yaml_file)
        print " Check for the file and that it is properly formatted YAML."
        print "Error:"
        print e
        sys.exit(1)   
        
    pattern =  paramsMap['pattern']
    paramsMap.pop('pattern')
       
    stack_name = '%s-%s' % (deployment_name, env_name)
    if args['opts']['name'] is not None and len(args['opts']['name']) > 1:
        stack_name = args['opts']['name']
        
    cf_dir='./patterns/%s' % (pattern)
    cf_filename='template.cf'
    cf_file = '%s/%s' % (cf_dir, cf_filename)
    #paramsMap['template_file'] = cf_file
        
    #
    # Use Jinja2
    # 
    template_dirs = [cf_dir, 'patterns/common/']
    jinjaFSloader = FileSystemLoader(template_dirs)
    env = Environment(loader=jinjaFSloader)    
    jinja_template = env.get_template(cf_filename)
    
    if args['subcmd'] == 'show-template':
        try:
            cf_json = json.loads(jinja_template.render(), object_pairs_hook=collections.OrderedDict)
            print json.dumps(cf_json, indent=4, separators=(',', ': '))
        except ValueError:
            print jinja_template.render()
            
            
    
    if args['subcmd'] == 'validate-template':
        print "Jinja2 template loading succeeded."
        try:
             cf_json = json.loads(jinja_template.render(), object_pairs_hook=collections.OrderedDict)
        except ValueError as e:
            print "Invalid JSON: "
            print e
            print ""
            print "Raw text:"
            print "------------------------"
            print jinja_template.render()
            sys.exit(1)      
        print "JSON valid."
        main_args=[
               'cloudformation', 
               'validate-template', 
               '--template-body', json.dumps(cf_json)
               ]
        return aws_driver.main(main_args)
                
        #print json.dumps(cf_json, sort_keys=True,indent=4, separators=(',', ': '))
    
    #
    # Load as JSON to validate it
    #
    try:
        cf_json = json.loads(jinja_template.render(), object_pairs_hook=collections.OrderedDict)
    except ValueError:
        print "Error parsing JSON"
        print jinja_template.render()
        sys.exit(1)
                
    if args['subcmd'] == 'deploy':
        
        main_args=[
               'cloudformation', 
               'create-stack', 
               '--capabilities', 'CAPABILITY_IAM', 
               '--disable-rollback',
               '--stack-name', stack_name
               ]
        if paramsMap is not None and len(paramsMap.keys()) > 0:
            main_args.append("--parameters")
            for key in paramsMap.keys():
                main_args.append("parameter_key=%s,parameter_value=%s" % (key, paramsMap[key]))
        
        main_args.append("--template-body")
        main_args.append(json.dumps(cf_json))

        return aws_driver.main(main_args)

    if args['subcmd'] == 'delete':
        
        main_args=[
               'cloudformation', 
               'delete-stack', 
               '--stack-name', stack_name
               ]
        return aws_driver.main(main_args)


if __name__ == '__main__':
    sys.exit(main())
    
